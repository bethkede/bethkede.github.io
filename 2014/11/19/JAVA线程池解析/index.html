<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JAVA线程池解析 | Bethkede&#39;s blog</title>
  <meta name="author" content="bethkede">
  
  <meta name="description" content="This is a blog of android">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="JAVA线程池解析"/>
  <meta property="og:site_name" content="Bethkede&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Bethkede&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Bethkede&#39;s blog</a></h1>
  <h2><a href="/">有时候生存往往比命运还残酷，只是没有人愿意认输</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-11-19T01:25:37.000Z"><a href="/2014/11/19/JAVA线程池解析/">11月 19 2014</a></time>
      
      
  
    <h1 class="title">JAVA线程池解析</h1>
  

    </header>
    <div class="entry">
      
        <h3 id="线程池的作用：">线程池的作用：</h3>
<p>线程池作用就是限制系统中执行线程的数量。<br>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。</p>
<h3 id="为什么要用线程池:">为什么要用线程池:</h3>
<p>1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。<br>2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
<a id="more"></a>

<p>Executor并不是一个线程池，他只是一个interface。ExecutorService才是真正的线程池，我们先来看看系统提供的集中线程池。可以关闭ExecutorService，这将导致其拒绝新任务。提供两个方法来关闭 ExecutorService.shutdown()方法在终止前允许执行以前提交的任务，而 shutdownNow() 方法阻止等待任务的启动并试图停止当前正在执行的任务。在终止后，执行程序没有任务在执行，也没有任务在等待执行，并且无法提交新任务。应该关闭未使用的 ExecutorService以允许回收其资源。</p>
<ul>
<li>newSingleThreadExecutor</li>
</ul>
<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<ul>
<li>newFixedThreadPool</li>
</ul>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<ul>
<li>newCachedThreadPool</li>
</ul>
<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<ul>
<li>newScheduledThreadPool</li>
</ul>
<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<p>其实他们都是实现了ThreadPoolExecutor而已。看下面的源码</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span>(ThreadFactory threadFactory) {
    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService
        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,
                                <span class="number">0</span>L, TimeUnit.MILLISECONDS,
                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),
                                threadFactory));
}


<span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span>(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory) {
    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,
                                  <span class="number">0</span>L, TimeUnit.MILLISECONDS,
                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),
                                  threadFactory);
}


<span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span>(ThreadFactory threadFactory) {
    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,
                                  <span class="number">60</span>L, TimeUnit.SECONDS,
                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre><p>看一下ThreadPoolExecutor的构造方法</p>
<pre><code><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span>(<span class="keyword">int</span> corePoolSize,
                          <span class="keyword">int</span> maximumPoolSize,
                          <span class="keyword">long</span> keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) 
</code></pre><p>corePoolSize： 线程池维护线程的最少数量<br>maximumPoolSize：线程池维护线程的最大数量<br>keepAliveTime： 线程池维护线程所允许的空闲时间<br>unit： 线程池维护线程所允许的空闲时间的单位<br>workQueue： 线程池所使用的缓冲队列<br>handler： 线程池对拒绝任务的处理策略</p>
<p>核心和最大池大小</p>
<p>ThreadPoolExecutor将根据corePoolSize（参见 getCorePoolSize()）和 maximumPoolSize（参见 getMaximumPoolSize()）<br>设置的边界自动调整池大小。当新任务在方法 execute(java.lang.Runnable) 中提交时，如果运行的线程少于 corePoolSize，    则创建新线程来处理请求，即使有线程是空闲的。<br>如果运行的线程多于 corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程。<br>如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。<br>如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。<br>在大多数情况下，核心和最大池大小仅基于构造来设置，不过也可以使用 setCorePoolSize(int) 和 setMaximumPoolSize(int) 进行动态更改。<br>注意1:在新任务被提交时，如果运行的core线程少于corePoolSize，才创建新core线程。并不是一开始就创建corePoolSize个core线程。<br>注意2:”如果运行的线程多于corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程”</p>
<p>按需构造</p>
<p>核心线程最初只是在新任务到达时才被ThreadPoolExecutor创建和启动的，<br>但是也可以手动调用方法 prestartCoreThread() 或 prestartAllCoreThreads()来的提前启动核心线程。<br>如果构造带有非空队列的池，这时则可能希望预先启动线程。<br>注意1：核心线程即core线程，只有当前线程数小于等于corePoolSize时，这时的线程才叫核心线程。</p>
<p>创建新线程</p>
<p>使用ThreadFactory创建新线程。如果没有另外说明，则使用 Executors.defaultThreadFactory() 创建线程，他们在同一个ThreadGroup中<br>并且这些线程具有相同的 NORM_PRIORITY 优先级和非守护进程状态。<br>通过提供不同的 ThreadFactory，可以改变线程的名称、线程组、优先级、守护进程状态，等等。<br>如果从 newThread 返回 null 时 ThreadFactory 未能创建线程，则执行程序将继续运行，但不能执行任何任务。<br>注意1:可以指定创建线程的ThreadFactory，默认的是使用Executors.defaultThreadFactory()来创建线程，所有的线程都在一个ThreadGroup中。</p>
<p>保持活动时间</p>
<p>如果池中当前有多于corePoolSize 的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止<br>参见 getKeepAliveTime(java.util.concurrent.TimeUnit)）。这提供了当池处于非活动状态时减少资源消耗的方法。<br>如果池后来变得更为活动，则可以创建新的线程。也可以使用方法 setKeepAliveTime(long, java.util.concurrent.TimeUnit) 动态地更改此参数。<br>如果把值设为Long.MAX_VALUE TimeUnit.NANOSECONDS 的话，空闲线程不会被回收直到ThreadPoolExecutor为Terminate。<br>默认情况下，保持活动策略只在有多于corePoolSizeThreads 的线程时应用。<br>但是只要 keepAliveTime 值非 0，allowCoreThreadTimeOut(boolean) 方法也可将此超时策略应用于核心线程。<br>注意1:setKeepAliveTime(long, java.util.concurrent.TimeUnit)用于设置空闲线程最长的活动时间，<br>即如果空闲时间超过设定值，就停掉该线程，对该线程进行回收。<br>该策略默认只对非内核线程有用（即当前线程数大于corePoolSize），<br>可以调用allowCoreThreadTimeOut(boolean)方法将此超时策略扩大到核心线程<br>注意2：如果把值设为Long.MAX_VALUE TimeUnit.NANOSECONDS的话，空闲线程不会被回收直到ThreadPoolExecutor为Terminate。</p>
<p>排队</p>
<p>所有 BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互：</p>
<pre><code><span class="bullet">* </span>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。
<span class="bullet">* </span>如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。
<span class="bullet">* </span>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。
</code></pre><p>排队有三种通用策略：</p>
<pre><code><span class="bullet">1. </span>直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。
   在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。
   此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。
   直接提交通常要求无界maximumPoolSizes以避免拒绝新提交的任务。
   当命令以超过队列所能处理的平均数连续到达时，此策略允许线程无界的增长。
注意1:此策略允许线程无界的增长。
<span class="bullet">2. </span>无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。
<span class="code">    这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）</span>
<span class="code">    当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。</span>
<span class="code">    这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许队列无限的增长。</span>
注意1：此策略允许队列无限的增长。
<span class="bullet">3. </span>有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。
<span class="code">    队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，</span>
<span class="code">    但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。</span>
<span class="code">    使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</span>
</code></pre><p>被拒绝的任务</p>
<p>当 Executor 已经关闭，或Executor将有限边界用于最大线程和工作队列容量，且已经饱和时，在方法 execute(java.lang.Runnable) 中提交的新任务将被拒绝。<br>在以上两种情况下，execute 方法都将调用其RejectedExecutionHandler的RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor) 方法。下面提供了四种预定义的处理程序策略：</p>
<pre><code>   <span class="number">1</span>. 在默认的 <span class="constant">ThreadPoolExecutor</span>.<span class="constant">AbortPolicy</span> 中，处理程序遭到拒绝将抛出运行时<span class="constant">RejectedExecutionException</span>。
   <span class="number">2</span>. 在 <span class="constant">ThreadPoolExecutor</span>.<span class="constant">CallerRunsPolicy</span>中，线程调用运行该任务的 execute 本身。
   此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。
   <span class="number">3</span>. 在<span class="constant">ThreadPoolExecutor</span>.<span class="constant">DiscardPolicy</span>中，不能执行的任务将被删除。
   <span class="number">4</span>. 在<span class="constant">ThreadPoolExecutor</span>.<span class="constant">DiscardOldestPolicy</span> 中，如果执行程序尚未关闭，
   则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。
定义和使用其他种类的<span class="constant">RejectedExecutionHandler</span>类也是可能的，但这样做需要非常小心，尤其是当策略仅用于特定容量或排队策略时
注意<span class="number">1</span><span class="symbol">:AbortPolicy</span>，<span class="constant">CallerRunsPolicy</span>，<span class="constant">DiscardPolicy</span>和<span class="constant">DiscardOldestPolicy</span>都是rejectedExecution的一种实现。
当然也可以自己定义个rejectedExecution实现。
</code></pre><p>钩子 (hook) 方法</p>
<p>此类提供 protected 可重写的 beforeExecute(java.lang.Thread, java.lang.Runnable)<br>和 afterExecute(java.lang.Runnable, java.lang.Throwable) 方法，这两种方法分别在执行每个任务之前和之后调用。<br>它们可用于操纵执行环境；例如，重新初始化 ThreadLocal、搜集统计信息或添加日志条目。<br>此外，还可以重写方法 terminated() 来执行 Executor 完全终止后需要完成的所有特殊处理。<br>如果钩子 (hook) 或回调方法抛出异常，则ThreadPoolExecutor的所有线程将依次失败并突然终止。 </p>
<p>队列维护</p>
<p>方法 getQueue() 允许出于监控和调试目的而访问工作队列。强烈反对出于其他任何目的而使用此方法。<br>remove(java.lang.Runnable) 和 purge() 这两种方法可用于在取消大量已排队任务时帮助进行存储回收。<br>注意1:如果任务取消，ThreadPoolExecutor应该自己是可以进行存储回收的。<br>取消的任务不会再次执行，但是它们可能在工作队列中累积，直到worker线程主动将其移除<br>外部使用remove(java.lang.Runnable)和purge()可以把它们立即从队列中移除。终止 如果ThreadPoolExecutor在程序中没有任何引用且没有任何活动线程，它也不会自动 shutdown。<br>如果希望确保回收线程（即使用户忘记调用 shutdown()），则必须安排未使用的线程最终终止：<br>设置适当保持活动时间，使用0核心线程的下边界和/或设置 allowCoreThreadTimeOut(boolean)。</p>
<p>扩展示例。此类的大多数扩展可以重写一个或多个受保护的钩子 (hook) 方法。例如，下面是一个添加了简单的暂停/恢复功能的子类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPoolExecutor</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">ThreadPoolExecutor</span> </span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;</div><div class="line">  <span class="keyword">private</span> ReentrantLock pauseLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">  <span class="keyword">private</span> Condition unpaused = pauseLock.newCondition();</div><div class="line"></div><div class="line">  <span class="keyword">public</span> PausableThreadPoolExecutor(...) { <span class="keyword">super</span>(...); </div><div class="line"></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> beforeExecute(Thread t, Runnable r) {</div><div class="line">    <span class="keyword">super</span>.beforeExecute(t, r);</div><div class="line">    pauseLock.lock();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">      <span class="keyword">while</span> (isPaused) unpaused.await();</div><div class="line">    } <span class="keyword">catch</span> (InterruptedException ie) {</div><div class="line">      t.interrupt();</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">      pauseLock.unlock();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> pause() {</div><div class="line">    pauseLock.lock();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">      isPaused = <span class="keyword">true</span>;</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">      pauseLock.unlock();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> resume() {</div><div class="line">    pauseLock.lock();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">      isPaused = <span class="keyword">false</span>;</div><div class="line">      unpaused.signalAll();</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">      pauseLock.unlock();</div><div class="line">    }</div><div class="line">  }</div><div class="line">}}</div></pre></td></tr></table></figure>

<h2 id="几点说明（重要）">几点说明（重要）</h2>
<p>block queue有以下几种实现：</p>
<ol>
<li>ArrayBlockingQueue :  有界的数组队列</li>
<li>LinkedBlockingQueue : 可支持有界/无界的队列，使用链表实现</li>
<li>PriorityBlockingQueue : 优先队列，可以针对任务排序</li>
<li>SynchronousQueue : 队列长度为1的队列，和Array有点区别就是：client thread提交到block queue会是一个阻塞过程，直到有一个worker thread连接上来poll task。<br>RejectExecutionHandler是针对任务无法处理时的一些自保护处理：</li>
<li>Reject 直接抛出Reject exception</li>
<li>Discard 直接忽略该runnable，不可取</li>
<li>DiscardOldest 丢弃最早入队列的的任务</li>
<li>CallsRun 直接让原先的client thread做为worker线程，进行执行</li>
</ol>
<p>容易被人忽略的点：</p>
<ol>
<li>pool threads启动后，以后的任务获取都会通过block queue中，获取堆积的runnable task.</li>
</ol>
<p>所以建议： block size &gt;= corePoolSize ，不然线程池就没任何意义</p>
<ol>
<li>corePoolSize 和 maximumPoolSize的区别， 和大家正常理解的数据库连接池不太一样。<ul>
<li>据dbcp pool为例，会有minIdle , maxActive配置。minIdle代表是常驻内存中的threads数量，maxActive代表是工作的最大线程数。</li>
<li>这里的corePoolSize就是连接池的maxActive的概念，它没有minIdle的概念(每个线程可以设置keepAliveTime，超过多少时间多有任务后销毁线程，但不会固定保持一定数量的threads)。 </li>
<li>这里的maximumPoolSize，是一种救急措施的第一层。当threadPoolExecutor的工作threads存在满负荷，并且block queue队列也满了，这时代表接近崩溃边缘。这时允许临时起一批threads，用来处理runnable，处理完后立马退出。</li>
</ul>
</li>
</ol>
<p>所以建议：  maximumPoolSize &gt;= corePoolSize =期望的最大线程数。 (我曾经配置了corePoolSize=1, maximumPoolSize=20, blockqueue为无界队列，最后就成了单线程工作的pool。典型的配置错误)</p>
<ol>
<li>善用blockqueue和reject组合. 这里要重点推荐下CallsRun的Rejected Handler，从字面意思就是让调用者自己来运行。<br>我们经常会在线上使用一些线程池做异步处理，比如我前面做的(业务层)异步并行加载技术分析和设计, 将原本串行的请求都变为了并行操作，但过多的并行会增加系统的负载(比如软中断，上下文切换)。所以肯定需要对线程池做一个size限制。但是为了引入异步操作后，避免因在block queue的等待时间过长，所以需要在队列满的时，执行一个callsRun的策略，并行的操作又转为一个串行处理，这样就可以保证尽量少的延迟影响。</li>
</ol>
<p>所以建议：  RejectExecutionHandler = CallsRun ,  blockqueue size = 2 * poolSize (为啥是2倍poolSize，主要一个考虑就是瞬间高峰处理，允许一个thread等待一个runnable任务)</p>
<p>文章大部分的出处：  <a href="http://blog.csdn.net/linghu_java/article/details/17123057" target="_blank" rel="external">http://blog.csdn.net/linghu_java/article/details/17123057</a><br>                    <a href="http://www.iteye.com/topic/1118660" target="_blank" rel="external">http://www.iteye.com/topic/1118660</a></p>

      
    </div>
    <footer>
      
        
        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
 
<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"bethkde"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->




<nav id="pagination" >
    
    
    <a href="/2014/11/18/Handler原理解析/" class="alignright next" >下一页</a>
    
    <div class="clearfix"></div>
</nav>

</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://baidu.com/" title="Baidu">Baidu</a></li>
</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 bethkede
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>